<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>DNA Font Animate (Framer Embed)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: black;
      overflow: hidden;
    }
    #framer-root {
      width: 100%;
      height: 100%;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="framer-root">
    <canvas id="canvas"></canvas>
  </div>

  <script>
    let canvas, ctx;
    let offCanvas, offCtx;
    let particles = [];

    const gap = 4;
    const threshold = 150;
    const springStrength = 0.05;
    const friction = 0.90;

    const repulsionRadius = 60;
    const repulsionForce = 0.7;

    const mouse = {
      x: 0,
      y: 0,
      active: false
    };

    function createTextParticles() {
      offCanvas.width = canvas.width;
      offCanvas.height = canvas.height;

      offCtx.clearRect(0, 0, offCanvas.width, offCanvas.height);
      offCtx.fillStyle = 'black';
      offCtx.fillRect(0, 0, offCanvas.width, offCanvas.height);

      offCtx.fillStyle = 'white';
      offCtx.textAlign = 'center';
      offCtx.textBaseline = 'middle';

      const fontSize = Math.min(canvas.width, canvas.height) / 4;
      offCtx.font = `bold ${fontSize}px impact`;
      offCtx.fillText('ДНК Хантфлоу', offCanvas.width / 2, offCanvas.height / 2);

      const imageData = offCtx.getImageData(0, 0, offCanvas.width, offCanvas.height);
      const data = imageData.data;

      particles = [];
      for (let y = 0; y < offCanvas.height; y += gap) {
        for (let x = 0; x < offCanvas.width; x += gap) {
          const index = (y * offCanvas.width + x) * 4;
          const r = data[index];
          if (r > threshold) {
            particles.push({
              x: x + Math.random() * 10 - 5,
              y: y + Math.random() * 10 - 5,
              tx: x,
              ty: y,
              vx: 0,
              vy: 0
            });
          }
        }
      }
    }

    function resize() {
      const container = document.getElementById('framer-root');
      const rect = container.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      createTextParticles();
    }

    function animate() {
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      particles.forEach(p => {
        if (mouse.active) {
          const dxm = p.x - mouse.x;
          const dym = p.y - mouse.y;
          const dist = Math.sqrt(dxm * dxm + dym * dym);
          if (dist < repulsionRadius) {
            const force = (repulsionRadius - dist) / repulsionRadius * repulsionForce;
            p.vx += (dxm / dist) * force;
            p.vy += (dym / dist) * force;
          }
        }

        const dx = p.tx - p.x;
        const dy = p.ty - p.y;
        p.vx += dx * springStrength;
        p.vy += dy * springStrength;

        p.vx *= friction;
        p.vy *= friction;

        p.x += p.vx;
        p.y += p.vy;

        ctx.beginPath();
        ctx.fillStyle = 'white';
        ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
        ctx.fill();
      });

      requestAnimationFrame(animate);
    }

    function init() {
      canvas = document.getElementById('canvas');
      ctx = canvas.getContext('2d');

      offCanvas = document.createElement('canvas');
      offCtx = offCanvas.getContext('2d');

      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left;
        mouse.y = e.clientY - rect.top;
        mouse.active = true;
      });

      canvas.addEventListener('mouseleave', () => {
        mouse.active = false;
      });

      const resizeObserver = new ResizeObserver(resize);
      resizeObserver.observe(document.getElementById('framer-root'));

      resize();
      animate();
    }

    init();
  </script>
</body>
</html>
